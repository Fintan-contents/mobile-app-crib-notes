---
title: ステートレスな認証
---


## Open ID Connect(OIDC)を使った認証フロー

PKCEでトークン取得するフローを簡単に説明します。
正確な仕様は[OpenID ファウンデーション・ジャパン](https://www.openid.or.jp/document/index.html)のサイトを御覧ください。OpenID関連技術仕様の日本語訳や、プレゼンテーション資料、その他各種文書を公開されています。

以下3者でやり取りします。

- End User
  - Relying Partyのサービスを利用する人。
- OpenID Provider
  - ユーザー認証の機能があり、Relying Partyから要求されたアイデンティティ情報を提供するエンドポイントを持つ。
- Relying Party
  - OpenID Providerにトークンとアイデンティティ情報を要求するサービス。


下記図に示すようなフローで、Relying Partyはトークン(アクセストークンとIDトークン、場合によってはリフレッシュトークンも含む)を保管します。最終的には、Relying Partyはこれらのトークンをリクエストに付与することで、認証が必要なエンドポイントにアクセスできます。

![](./oidc-flow.drawio.png)


OIDC認証フローで、もう1つ重要なのが2015年9月に[RFC 7636](https://tools.ietf.org/html/rfc7636)として公開された仕様があります。こちらは、認可コード横取り攻撃(authorization code interception attack)への対策として策定されたものです。詳細は以下の記事を御覧ください。
- [PKCE: 認可コード横取り攻撃対策のために OAuth サーバーとクライアントが実装すべきこと - Qiita](https://qiita.com/TakahikoKawasaki/items/00f333c72ed96c4da659)

### モバイルアプリケーションの役割

上記で説明したOIDC認証のフローの中のRelying Partyが、モバイルアプリケーションに該当します。
そのためモバイルアプリケーションは以下のような役割を担います。
- OIDC認証の開始
  - エンドユーザーの指示に従って、OIDC Providerの認可エンドポイントにリダイレクトでリクエストを送信する
- トークン取得・保管
  - OIDC Providerから返却される認可コードを受け取り、Open Providerのトークンエンドポイントに認可コードを付与したトークン取得リクエストを送る
  - レスポンスからトークンを取得し、モバイルアプリケーションのストレージに保管する
- 認証が必要なエンドポイントへのアクセス
  - トークンをリクエストに付与して認証が必要なエンドポイントにアクセスする


## トークン

OIDC認証を使う場合、モバイルアプリケーションでトークンを管理する必要があります。
ここではトークンの種類と役割、保管方法、ライフサイクル管理などを示します。


### トークンの種類
OIDC認証で利用されるトークン(JSON Web Token)は全部で3種類あります。

- IDトークン
  - ユーザーの属性が含まれています
  - 通常IDトークンには短い有効期限が設定されます
  - 認証に使用されます。リソースサーバーでイシュアーの管理するID情報が必要な場合に使用されます
- アクセストークン
  - リソースアクセスに必要な情報が含まれています
  - 通常アクセストークンには短い有効期限が設定されます
  - 認可に使用されます。リソースサーバーへのアクセスコントロールを目的として使用されます
- リフレッシュトークン
  - 新しいIDトークンもしくはアクセストークンを発行するために必要な情報が含まれています
  - IDトークンもしくはアクセストークンの期限が切れた後に、再発行するために使用します
  - リフレッシュトークンには比較的長めの有効期限が設定されます


### トークンの保管方法

プラットフォームに応じてセキュアな方法でトークンを保管しましょう。
* Android: KeyStoreに保存した鍵で暗号化したトークンを保管する
* iOS: KeyChainにトークンを保管する


## 認証状態のライフサイクル管理

AndroidならKeyStore、iOSならKeyChainに保存することを前提に、認証状態のライフサイクル管理について説明します。

### KeyStore

KeyStoreに保存した鍵は、以下のような操作で消えてしまいます。鍵が取得できない場合はユーザに再度ログイン操作を要求する必要があります。
* アプリのアンインストール
* [ユーザが認証された状態でしか鍵を利用できないように設定している場合](https://developer.android.com/training/articles/keystore?hl=ja#UserAuthentication)は、次の場合
  * セキュアロック画面が無効化された場合や強制的にリセットされた場合
  * 新しい指紋が登録された場合やすべての指紋の登録が抹消された場合

### KeyChain

KeyChainは以下の特性があるため、要件によっては設定変更または個別にロジックの実装が必要です。

#### 1. アプリをアンインストールしても消えない

特に何もしない場合は、再インストール時に認証状態が引き継がれることになります。
もしインストール後に必ず認証するような仕様の場合は、UserDefaultsにフラグを設けてログイン状態を管理などの実装が必要になります。

#### 2. iCloud同期により同じAppleIDでログインしている別の端末に同期される

iCloud同期のタイミングは不定期のため、いつバックアップ/同期されるか分かりません。
特に1度しか使えないような仕様のアクセストークンやリフレッシュトークンが同期されてしまい、複数台で同時に利用されると予期しない不整合が発生してしまう可能性があります。



## OIDC認証のパターン

モバイルアプリケーションにおいてOIDC認証は、どのようにログイン画面(認証情報を入力する画面)を表示するかによってパターンがいくつかあります。
パターンごとの特徴を以下に示します。
プロジェクトの要件に応じて選択できますが、一般的にIn-App Browserで表示することが多いようです。


| 選択肢                |1アプリケーション内で認証が完結 | Cookie共有(Default Browserと) | UIのカスタム | 処理のカスタム | セキュリティポリシー |
|--------------------|-------------|------------------|------|----------------------------|---------|
| Default Browser           | ☓                | ○                          | ☓       | ☓       | ブラウザベンダー準拠 |
| In-App Browser            | ○                | ○                          | △       | ☓       | ブラウザベンダー準拠 |
| ~~WebView~~ **(※2)**   | ~~○~~            | ~~☓~~                      | ~~○~~   | ~~○~~   | ~~開発者次第~~  |


前述しました通り、ブラウザには以下の3種類があり、OSごとに以下が用意されています。

| ブラウザの種類 ＼ OS    | Android            | iOS                    |
|-----------------|--------------------|------------------------|
| Default Browser | Chrome             | Safari                 |
| In-App Browser  | Chrome Custom Tabs | SFSafariViewController/SFAuthenticationSession/ASWebAuthenticationSession |
| WebView         | WebView            | WKWebView              |

{{<hint danger>}}
**(※2)** OIDC認証の場合でブラウザを使う場合はWebViewを使わないでください。
代わりにIn-App Browserを使うように、2016/8にGoogle Developersから[勧告](https://developers.googleblog.com/2016/08/modernizing-oauth-interactions-in-native-apps.html)が出ています。
{{</hint >}}



以下に詳細を示します。

### 1. Default Browser

![](./authn-pattern-defaultbrowser.png)

#### 長所

- ユーザーが普段使い慣れたアプリケーションなので操作しやすい
- SNS認証などの場合、一度Default Browserでログインしておけば、改めてログインする必要がない
- セキュリティポリシーがブラウザベンダー準拠


#### 短所

- 別アプリケーション(ChromeかSafari)なのでUIをカスタムできない
- 別アプリケーション(ChromeかSafari)を開いて認証後に戻ってくる必要があるので、UXが多少低下する

<br/>

### 2. In-App Browser

![](./authn-pattern-inappbrowser.png)

#### 長所

- アプリケーション内で認証が完結するのでUXが良い
- Default BrowserとCookieを共有できるので、一度Default Browserでログインしておけば、改めてログインする必要がない
- セキュリティポリシーがブラウザベンダー準拠

#### 短所

- UIはツールバーの色、閉じるボタンのアイコンなどしかカスタムできない



